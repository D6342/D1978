import torch
import torch.nn as nn 
import torch.optim as optim
from torchvision import datasets, transforms 
from torch.utils.data import DataLoader 
import matplotlib.pyplot as plt

# Hyperparameters 
latent_dim = 100
img_shape = (1, 28, 28)
batch_size = 64
epochs = 100

# Generator
class Generator(nn.Module): 
    def  init (self):
        super(Generator, self). init () 
        self.model = nn.Sequential(
            nn.Linear(latent_dim, 128), 
            nn.ReLU(),
            nn.Linear(128, 256), 
            nn.ReLU(), 
            nn.Linear(256, 28 * 28), 
            nn.Tanh()
        )

    def forward(self, z): 
        img = self.model(z)
        img = img.view(img.size(0), *img_shape) 
        return img

# Discriminator
class Discriminator(nn.Module): 
    def __init__(self):
        super(Discriminator, self).__init__() 
        self.model = nn.Sequential(
            nn.Flatten(), 
            nn.Linear(28 * 28, 128), 
            nn.ReLU(), 
            nn.Linear(128, 1), 
            nn.Sigmoid()
        )

  def forward(self, img): 
      validity = self.model(img) 
      return validity
 
# Initialize models 
generator = Generator()
discriminator = Discriminator()

# Loss and optimizer 
adversarial_loss = nn.BCELoss()
optimizer_G = optim.Adam(generator.parameters(), lr=0.0002) 
optimizer_D = optim.Adam(discriminator.parameters(), lr=0.0002)

# Load data
transform = transforms.Compose([ 
    transforms.ToTensor(),
    transforms.Normalize([0.5], [0.5]) # Normalize to [-1, 1]
])
dataloader = DataLoader(datasets.MNIST('.', train=True, download=True, 
transform=transform), batch_size=batch_size, shuffle=True)

# Training loop
for epoch in range(epochs):
    for i, (imgs, _) in enumerate(dataloader): 
        # Ground truths
        valid = torch.ones(imgs.size(0), 1) 
        fake = torch.zeros(imgs.size(0), 1)

        # Train discriminator 
        real_imgs = imgs 
        optimizer_D.zero_grad()
        z = torch.randn(imgs.size(0), latent_dim) 
        gen_imgs = generator(z)
        d_loss_real = adversarial_loss(discriminator(real_imgs), valid) 
        d_loss_fake = adversarial_loss(discriminator(gen_imgs.detach()),
fake)
        d_loss = d_loss_real + d_loss_fake 
        d_loss.backward() 
        optimizer_D.step()
 
        # Train generator 
        optimizer_G.zero_grad()
        g_loss = adversarial_loss(discriminator(gen_imgs), valid) 
        g_loss.backward()
        optimizer_G.step()

    #print(f"[Epoch {epoch + 1}/{epochs}] D Loss: {d_loss.item():.4f}, 
G Loss: {g_loss.item():.4f}")
    if epoch % 10 == 0:
        gen_imgs = gen_imgs[:5].detach().cpu().numpy()
        gen_imgs = 0.5 * gen_imgs + 0.5 # Rescale back to [0, 1] 
        for i in range(5):
            plt.subplot(1, 5, i + 1)
            plt.imshow(gen_imgs[i, 0], cmap="gray") 
            plt.axis("off")
        plt.show()
